<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Rythum's European Grand Tour &amp; Weather</title>

    <!-- Leaflet -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
    <!-- MarkerCluster -->
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.css" />
    <link rel="stylesheet" href="https://unpkg.com/leaflet.markercluster@1.5.3/dist/MarkerCluster.Default.css" />

    <style>
        :root{
            --terracotta:#E2725B;
            --azure:#3498DB;
            --gold:#F1C40F;
            --stone:#2C3E50;
            --paper:#FCF9F2;
            --muted:#7f8c8d;
        }

        html,body{height:100%;margin:0;font-family:Georgia,serif;background-color:var(--paper);}
        body{
            display:flex;
            flex-direction:column;
            min-height:100vh;
            background-image: linear-gradient(rgba(252,249,242,0.92), rgba(252,249,242,0.92)),
                              url('https://images.unsplash.com/photo-1467269204594-9661b134dd2b?auto=format&fit=crop&q=80&w=2000');
            background-size:cover;background-attachment:fixed;
        }

        / Layout /
        #app { display:flex; flex-direction:column; flex:1; min-height:0; }
        @media(min-width:768px){
            #app { flex-direction:row; }
            #sidebar { width:420px; height:100vh; border-right:3px double var(--terracotta); box-sizing:border-box; }
            #map { height:100vh; }
        }

        #sidebar{
            padding:24px; overflow-y:auto; background:rgba(255,255,255,0.85); backdrop-filter: blur(6px);
        }

        #map{ height:350px; flex:1; z-index:1; border-bottom:3px solid var(--terracotta); }

        h1{ font-style:italic; color:var(--terracotta); margin:0 0 8px 0; font-size:1.6rem; text-align:center; }
        .sub { text-align:center; color:var(--muted); font-size:0.9rem; margin-bottom:12px; }

        / Status card /
        #status-card{ background:var(--stone); color:white; padding:14px; border-radius:8px; margin-bottom:18px; box-shadow:0 4px 15px rgba(0,0,0,0.18); }
        .weather-info{ display:flex; align-items:center; justify-content:space-between; margin-top:10px; padding-top:10px; border-top:1px solid rgba(255,255,255,0.12); }
        .temp{ font-size:1.4rem; font-weight:700; color:var(--gold); }
        .condition{ font-size:0.9rem; text-transform:capitalize; opacity:0.95; }

        / Controls /
        .controls{ display:flex; gap:8px; margin-bottom:14px; flex-wrap:wrap; }
        .controls button, .controls input[type="file"]{
            background:var(--azure); color:white; border:0; padding:8px 10px; border-radius:6px; cursor:pointer; font-weight:600;
        }
        .controls button.secondary{ background:transparent; color:var(--stone); border:1px solid rgba(44,62,80,0.08); }
        .controls input[type="file"]{ padding:6px; font-size:0.9rem; }

        / Timeline /
        .timeline { list-style:none; padding:0; margin:0; position:relative; }
        .timeline::before{ content:''; position:absolute; left:18px; top:0; bottom:0; width:2px; background:var(--terracotta); opacity:0.25; }
        .step{ margin-bottom:22px; padding-left:56px; position:relative; cursor:pointer; outline:none; }
        .step::before{ content:'‚Ä¢'; position:absolute; left:6px; top:-6px; font-size:36px; color:var(--stone); }
        .step.completed::before{ color:var(--terracotta); content:'‚úì'; font-size:22px; left:8px; top:0; }
        .step.active::before{ color:var(--azure); animation:pulse 2s infinite; }
        @keyframes pulse{ 0%{ transform:scale(1); text-shadow:0 0 0px var(--azure);} 50%{ transform:scale(1.25); text-shadow:0 0 10px var(--azure);} 100%{ transform:scale(1);} }

        .location{ font-size:1.05rem; font-weight:700; color:#111; }
        .info{ font-size:0.85rem; color:#555; font-style:italic; margin-top:4px; }
        .meta{ font-size:0.78rem; color:var(--muted); margin-top:6px; }

        / Playback bar /
        #playback{ display:flex; gap:8px; align-items:center; margin:12px 0 18px 0; }
        #playback button{ padding:8px 10px; border-radius:6px; border:0; background:var(--azure); color:white; cursor:pointer; }
        #playback input[type="range"]{ flex:1; }

        / Small utilities /
        .sr-only{ position:absolute; left:-10000px; top:auto; width:1px; height:1px; overflow:hidden; }
        .card{ background:white; padding:10px; border-radius:8px; box-shadow:0 2px 8px rgba(0,0,0,0.06); margin-bottom:12px; }

        / Custom marker styling via divIcon /
        .custom-marker { display:flex; align-items:center; justify-content:center; }
        .custom-marker svg { filter: drop-shadow(0 2px 4px rgba(0,0,0,0.25)); }

        / Responsive tweaks /
        @media(max-width:767px){
            #sidebar{ height:auto; }
            #map{ height:320px; }
        }
    </style>
</head>
<body>
<div id="app">
    <div id="map" aria-hidden="false"></div>

    <aside id="sidebar" role="region" aria-label="Trip sidebar">
        <h1>Bon Voyage, Rythum</h1>
        <div class="sub">Interactive timeline, map playback, weather caching, and save/export</div>

        <div id="status-card" role="status" aria-live="polite">
            <div id="location-text">Detecting location...</div>
            <div id="weather-box" class="weather-info" style="display:none;">
                <div>
                    <div class="condition" id="weather-desc">Clear Sky</div>
                    <div style="font-size:0.75rem; opacity:0.85;">Current Weather</div>
                </div>
                <div class="temp" id="weather-temp">--¬∞C</div>
            </div>
        </div>

        <div class="controls card" aria-hidden="false">
            <button id="save-btn" title="Save itinerary to local storage">Save</button>
            <button id="load-btn" class="secondary" title="Load itinerary from local storage">Load</button>
            <button id="export-btn" title="Export itinerary JSON">Export</button>
            <label for="import-file" class="secondary" style="display:inline-block; padding:8px 10px; border-radius:6px; cursor:pointer; background:transparent; border:1px solid rgba(44,62,80,0.08); color:var(--stone);">Import</label>
            <input id="import-file" type="file" accept="application/json" style="display:none" />
        </div>

        <div id="playback" class="card" aria-hidden="false">
            <button id="play-btn" aria-pressed="false">Play</button>
            <button id="pause-btn" disabled>Pause</button>
            <button id="stop-btn" disabled>Stop</button>
            <input id="speed" type="range" min="200" max="3000" step="100" value="1000" aria-label="Playback speed" />
        </div>

        <div class="card" style="padding:12px;">
            <strong>Itinerary</strong>
            <ul class="timeline" id="timeline" role="list"></ul>
        </div>
    </aside>
</div>

<!-- Scripts -->
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/leaflet.markercluster@1.5.3/dist/leaflet.markercluster.js"></script>

<script>
/*
  Enhanced single-file version:
  - timezone-aware status checks (ISO strings preserved)
  - weather caching + debounce
  - marker clustering + custom SVG markers
  - polylines connecting itinerary
  - playback controls (play/pause/stop) with speed control
  - localStorage save/load and JSON export/import
  - accessible timeline items (keyboard focusable)
  - deep-linking via URL hash (#id) to center a location
*/

/ ---------- Sample itinerary (canonical schema) ---------- /
let itinerary = [
    { id: "1", start: "2026-02-14T10:00:00-05:00", end: "2026-02-14T12:00:00-05:00", label: "Toronto", info: "Flight Departure", lat: 43.6532, lng: -79.3832, tags:["departure"] },
    { id: "2", start: "2026-02-15T09:00:00+01:00", end: "2026-02-15T18:00:00+01:00", label: "Rome", info: "The Eternal City", lat: 41.9028, lng: 12.4964, tags:["city"] },
    { id: "3", start: "2026-02-16T09:05:00+01:00", end: "2026-02-16T12:00:00+01:00", label: "Colosseum", info: "Ancient Wonders", lat: 41.8902, lng: 12.4922, tags:["landmark","history"] },
    { id: "4", start: "2026-02-17T09:42:00+01:00", end: "2026-02-17T17:00:00+01:00", label: "Venice", info: "Canals & Art", lat: 45.4408, lng: 12.3155, tags:["city"] },
    { id: "5", start: "2026-02-18T09:45:00+01:00", end: "2026-02-18T20:00:00+01:00", label: "Milan", info: "Fashion Capital", lat: 45.4642, lng: 9.1900, tags:["city"] },
    { id: "6", start: "2026-02-18T22:36:00+01:00", end: "2026-02-19T10:00:00+01:00", label: "Paris", info: "City of Light", lat: 48.8566, lng: 2.3522, tags:["city"] },
    { id: "7", start: "2026-02-21T18:30:00+01:00", end: "2026-02-21T20:00:00+01:00", label: "Eiffel Tower", info: "Final Farewell", lat: 48.8584, lng: 2.2945, tags:["landmark"] }
];

/ ---------- Map setup ---------- /
const map = L.map('map', { zoomControl: true }).setView([48,2], 4);
L.tileLayer('https://{s}.basemaps.cartocdn.com/light_all/{z}/{x}/{y}{r}.png', {
    attribution: '&copy; OpenStreetMap contributors'
}).addTo(map);

/ Marker cluster group /
const clusterGroup = L.markerClusterGroup();
map.addLayer(clusterGroup);

/ Polyline layer /
let routeLine = L.polyline([], { color: '#3498DB', weight: 3, opacity: 0.7 }).addTo(map);

/ ---------- Utilities ---------- /
function parseISO(iso) {
    // Keep the timezone offset in the ISO string; Date will interpret it correctly.
    return new Date(iso);
}

function formatLocal(iso) {
    const d = parseISO(iso);
    return d.toLocaleString(undefined, { dateStyle: 'medium', timeStyle: 'short' });
}

function getStatus(item, now = new Date()) {
    const start = parseISO(item.start);
    const end = item.end ? parseISO(item.end) : null;
    if (end && now >= end) return 'completed';
    if (now >= start && (!end || now < end)) return 'active';
    return 'future';
}

/ ---------- Weather caching + debounce ---------- /
const weatherCache = new Map();
const weatherPending = new Map();
function cacheKey(lat, lng) {
    return ${lat.toFixed(4)},${lng.toFixed(4)};
}
async function fetchWeather(lat, lng) {
    const key = cacheKey(lat,lng);
    if (weatherCache.has(key)) return weatherCache.get(key);
    if (weatherPending.has(key)) return weatherPending.get(key);

    const p = (async () => {
        try {
            const res = await fetch(https://api.open-meteo.com/v1/forecast?latitude=${lat}&longitude=${lng}&current_weather=true);
            const json = await res.json();
            const w = json.current_weather || null;
            if (w) {
                weatherCache.set(key, w);
                // expire after 10 minutes
                setTimeout(() => weatherCache.delete(key), 10  60  1000);
            }
            return w;
        } catch (e) {
            console.error('Weather fetch failed', e);
            return null;
        } finally {
            weatherPending.delete(key);
        }
    })();
    weatherPending.set(key, p);
    return p;
}

/ ---------- Custom marker icon factory ---------- /
function circleIcon(color, labelChar) {
    const svg = `
      <svg width="36" height="36" viewBox="0 0 36 36" xmlns="http://www.w3.org/2000/svg" aria-hidden="true">
        <circle cx="18" cy="18" r="12" fill="${color}" />
        <text x="18" y="22" text-anchor="middle" font-size="12" font-family="sans-serif" fill="#fff">${labelChar || ''}</text>
      </svg>`;
    return L.divIcon({
        className: 'custom-marker',
        html: svg,
        iconSize: [36,36],
        iconAnchor: [18,36],
        popupAnchor: [0,-36]
    });
}

/ ---------- Rendering itinerary on map and timeline ---------- /
let markerMap = new Map(); // id -> marker
const timelineEl = document.getElementById('timeline');
const locationText = document.getElementById('location-text');
const weatherBox = document.getElementById('weather-box');
const weatherDesc = document.getElementById('weather-desc');
const weatherTemp = document.getElementById('weather-temp');

function clearMap() {
    clusterGroup.clearLayers();
    markerMap.clear();
    routeLine.setLatLngs([]);
}

function buildMapAndTimeline() {
    clearMap();
    timelineEl.innerHTML = '';
    const now = new Date();
    const latlngs = [];

    itinerary.forEach((item, idx) => {
        const status = getStatus(item, now);
        const color = status === 'active' ? '#3498DB' : status === 'completed' ? '#E2725B' : '#95A5A6';
        const labelChar = item.label ? item.label.charAt(0).toUpperCase() : '';
        const marker = L.marker([item.lat, item.lng], { icon: circleIcon(color, labelChar) });

        // Popup content with local time and original ISO
        const popupHtml = `
            <div style="min-width:180px">
              <strong>${escapeHtml(item.label)}</strong><br/>
              <div style="font-size:0.85rem;color:#444;margin-top:4px">${escapeHtml(item.info)}</div>
              <div class="meta" style="margin-top:8px;color:#666">
                <div>Start: ${formatLocal(item.start)}</div>
                <div style="font-size:0.8rem;color:#888">ISO: ${item.start}</div>
              </div>
            </div>
        `;
        marker.bindPopup(popupHtml, { minWidth: 200 });

        marker.on('click', () => {
            // update hash for deep-linking
            location.hash = #${encodeURIComponent(item.id)};
        });

        clusterGroup.addLayer(marker);
        markerMap.set(item.id, marker);
        latlngs.push([item.lat, item.lng]);

        // Timeline item
        const li = document.createElement('li');
        li.className = step ${status};
        li.setAttribute('role','listitem');
        li.setAttribute('tabindex','0');
        li.setAttribute('data-id', item.id);
        li.innerHTML = `
            <div class="location">${escapeHtml(item.label)}</div>
            <div class="info">${escapeHtml(item.info)}</div>
            <div class="meta">Start: ${formatLocal(item.start)}</div>
        `;
        li.addEventListener('click', () => {
            focusOnItem(item.id);
        });
        li.addEventListener('keydown', (e) => {
            if (e.key === 'Enter' || e.key === ' ') { e.preventDefault(); focusOnItem(item.id); }
        });
        timelineEl.appendChild(li);
    });

    // draw polyline
    routeLine.setLatLngs(latlngs);

    // center map to bounds
    if (latlngs.length) {
        const bounds = L.latLngBounds(latlngs);
        map.fitBounds(bounds.pad(0.2));
    }

    // if hash present, focus
    const hash = location.hash.replace('#','');
    if (hash) {
        const id = decodeURIComponent(hash);
        if (markerMap.has(id)) focusOnItem(id, { zoom: 13 });
    }

    // update current location/weather if any active
    updateCurrentStatus();
}

/ ---------- Focus / flyTo ---------- /
function focusOnItem(id, opts = { zoom: 13 }) {
    const marker = markerMap.get(id);
    if (!marker) return;
    const latlng = marker.getLatLng();
    map.flyTo(latlng, opts.zoom || 13, { animate: true, duration: 1.0 });
    marker.openPopup();
    // highlight timeline item visually
    document.querySelectorAll('.timeline .step').forEach(el => el.classList.remove('focused'));
    const el = document.querySelector(.timeline .step[data-id="${CSS.escape(id)}"]);
    if (el) el.classList.add('focused');
}

/ ---------- Current status & weather display ---------- /
let lastWeatherLocationKey = null;
let weatherDebounceTimer = null;
function updateCurrentStatus() {
    const now = new Date();
    // find active item (first active)
    const active = itinerary.find(item => getStatus(item, now) === 'active');
    if (active) {
        locationText.innerHTML = üìç Currently: <b>${escapeHtml(active.label)}</b>;
        // fetch weather (debounced to avoid rapid calls)
        const key = cacheKey(active.lat, active.lng);
        if (key !== lastWeatherLocationKey) {
            lastWeatherLocationKey = key;
            if (weatherDebounceTimer) clearTimeout(weatherDebounceTimer);
            weatherDebounceTimer = setTimeout(async () => {
                const w = await fetchWeather(active.lat, active.lng);
                if (w) {
                    weatherBox.style.display = 'flex';
                    weatherTemp.innerText = ${Math.round(w.temperature)}¬∞C;
                    const codes = { 0: "Clear Sky", 1: "Mainly Clear", 2: "Partly Cloudy", 3: "Overcast", 45: "Fog", 48: "Depositing rime fog", 51: "Light drizzle", 61: "Rain", 80: "Rain showers" };
                    weatherDesc.innerText = codes[w.weathercode] || "Fair Conditions";
                } else {
                    weatherBox.style.display = 'none';
                }
            }, 250); // small debounce
        }
    } else {
        locationText.innerHTML = No active stop right now;
        weatherBox.style.display = 'none';
        lastWeatherLocationKey = null;
    }

    // update timeline classes
    document.querySelectorAll('.timeline .step').forEach(el => {
        const id = el.getAttribute('data-id');
        const item = itinerary.find(it => it.id === id);
        if (!item) return;
        el.classList.remove('active','completed','future');
        el.classList.add(getStatus(item));
    });
}

/ ---------- Playback controls ---------- /
let playbackTimer = null;
let playbackIndex = 0;
let isPlaying = false;

const playBtn = document.getElementById('play-btn');
const pauseBtn = document.getElementById('pause-btn');
const stopBtn = document.getElementById('stop-btn');
const speedInput = document.getElementById('speed');

function startPlayback() {
    if (isPlaying) return;
    if (!itinerary.length) return;
    isPlaying = true;
    playBtn.setAttribute('aria-pressed','true');
    pauseBtn.disabled = false;
    stopBtn.disabled = false;
    playBtn.disabled = true;

    // start from current active or beginning
    const now = new Date();
    playbackIndex = itinerary.findIndex(it => getStatus(it, now) === 'active');
    if (playbackIndex < 0) playbackIndex = 0;

    const step = () => {
        if (playbackIndex >= itinerary.length) {
            stopPlayback();
            return;
        }
        const item = itinerary[playbackIndex++];
        focusOnItem(item.id, { zoom: 10 });
        // highlight timeline item
        const el = document.querySelector(.timeline .step[data-id="${CSS.escape(item.id)}"]);
        if (el) {
            el.scrollIntoView({ behavior: 'smooth', block: 'center' });
        }
    };

    // immediate first step
    step();
    playbackTimer = setInterval(step, Number(speedInput.value) || 1000);
}

function pausePlayback() {
    if (!isPlaying) return;
    clearInterval(playbackTimer);
    playbackTimer = null;
    isPlaying = false;
    playBtn.setAttribute('aria-pressed','false');
    playBtn.disabled = false;
    pauseBtn.disabled = true;
}

function stopPlayback() {
    clearInterval(playbackTimer);
    playbackTimer = null;
    isPlaying = false;
    playbackIndex = 0;
    playBtn.setAttribute('aria-pressed','false');
    playBtn.disabled = false;
    pauseBtn.disabled = true;
    stopBtn.disabled = true;
}

/ ---------- Persistence: save/load/export/import ---------- /
const STORAGEKEY = 'rythumitinerary_v1';

document.getElementById('save-btn').addEventListener('click', () => {
    try {
        localStorage.setItem(STORAGE_KEY, JSON.stringify(itinerary));
        alert('Itinerary saved locally.');
    } catch (e) {
        console.error('Save failed', e);
        alert('Save failed.');
    }
});

document.getElementById('load-btn').addEventListener('click', () => {
    try {
        const raw = localStorage.getItem(STORAGE_KEY);
        if (!raw) { alert('No saved itinerary found.'); return; }
        const parsed = JSON.parse(raw);
        if (Array.isArray(parsed)) {
            itinerary = parsed;
            buildMapAndTimeline();
            alert('Itinerary loaded.');
        } else {
            alert('Saved data is invalid.');
        }
    } catch (e) {
        console.error('Load failed', e);
        alert('Load failed.');
    }
});

document.getElementById('export-btn').addEventListener('click', () => {
    const blob = new Blob([JSON.stringify(itinerary, null, 2)], { type: 'application/json' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'itinerary.json';
    document.body.appendChild(a);
    a.click();
    a.remove();
    URL.revokeObjectURL(url);
});

document.getElementById('import-file').addEventListener('change', (e) => {
    const f = e.target.files[0];
    if (!f) return;
    const reader = new FileReader();
    reader.onload = (ev) => {
        try {
            const parsed = JSON.parse(ev.target.result);
            if (!Array.isArray(parsed)) throw new Error('Invalid format');
            // basic validation: ensure id/start/lat/lng exist
            const ok = parsed.every(it => it.id && it.start && typeof it.lat === 'number' && typeof it.lng === 'number');
            if (!ok) throw new Error('Missing required fields');
            itinerary = parsed;
            buildMapAndTimeline();
            alert('Itinerary imported.');
        } catch (err) {
            console.error('Import failed', err);
            alert('Import failed: ' + err.message);
        }
    };
    reader.readAsText(f);
});

/ ---------- Helpers ---------- /
function escapeHtml(s) {
    if (!s) return '';
    return String(s).replace(/[&<>"']/g, function(m) {
        return ({'&':'&amp;','<':'&lt;','>':'&gt;','"':'&quot;',"'":'&#39;'}[m]);
    });
}

/ ---------- Event wiring ---------- /
playBtn.addEventListener('click', startPlayback);
pauseBtn.addEventListener('click', pausePlayback);
stopBtn.addEventListener('click', stopPlayback);
speedInput.addEventListener('input', () => {
    if (isPlaying) {
        clearInterval(playbackTimer);
        playbackTimer = setInterval(() => {
            if (playbackIndex >= itinerary.length) { stopPlayback(); return; }
            const item = itinerary[playbackIndex++];
            focusOnItem(item.id, { zoom: 10 });
        }, Number(speedInput.value));
    }
});

/ Update current status periodically (every 30s) to reflect time changes /
setInterval(updateCurrentStatus, 30 * 1000);

/ Rebuild map/timeline initially /
buildMapAndTimeline();

/ Rebuild when window regains focus (in case time changed) /
window.addEventListener('focus', () => {
    updateCurrentStatus();
});

/ Allow deep-linking: if hash changes, focus on that item /
window.addEventListener('hashchange', () => {
    const id = decodeURIComponent(location.hash.replace('#',''));
    if (id && markerMap.has(id)) focusOnItem(id, { zoom: 13 });
});

/ Accessibility: keyboard shortcuts (optional) /
window.addEventListener('keydown', (e) => {
    if (e.key === 'k' && (e.ctrlKey || e.metaKey)) {
        // Ctrl/Cmd+K focuses timeline for quick navigation
        const first = document.querySelector('.timeline .step');
        if (first) first.focus();
        e.preventDefault();
    }
});

/ Expose a small API for debugging in console /
window.rythum = {
    itinerary,
    rebuild: buildMapAndTimeline,
    fetchWeather,
    focusOnItem
};
</script>
</body>
</html>
